<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Himal Sherchan - Circular Buffer</title>
  <link rel="shortcut icon" href="/assets/images/favicon.ico">
  <link rel="stylesheet" href="/assets/css/style.css">
  <link rel="alternate" type="application/rss+xml" title="My Blog" href="/rss.xml">
  <link rel="stylesheet" href="/assets/css/highlight.css">
</head>
<body>

  <nav class="main-nav">
    
        <a href="/"> <span class="arrow">←</span> Home </a>
    

    
        
            <a href="/about">About </a>
        
    
    <a class="cta" href="/feed.xml">Subscribe</a>
</nav>

  

  <section id="wrapper" class="">
    <article class="post">
    <header>
        <h1>Circular Buffer</h1>
        <h2 class="headline">May 12, 2016</h2>
    </header>
    <section id="post-body">
        <p>Circular buffer/Ring buffer/Cyclic buffer store data in a FIFO (First In First Out) queue. The code in my github repo is a small example of how it should function. It could certainly be optimized for larger spaces. However, for this case the circular buffer has a pre-determined size. It uses byte array to store data and pointers to depict the circular behavior. Circular buffers could have a lot of uses. One that I can think on top of my head is cache memory.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">uint8_t</span> <span class="n">maxSize</span><span class="p">;</span>
<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">origBufferAddress</span><span class="p">;</span>
<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">readPtr</span><span class="p">;</span>
<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">writePtr</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">initialize</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">buffer</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
    
    <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
    <span class="n">maxSize</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
    
    <span class="c1">//Initializes all the pointers as well.
</span>    <span class="n">origBufferAddress</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">writePtr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">readPtr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>So <strong>origBufferAddress</strong> pointer always keeps track of the starting address of the buffer. As the <strong>readPtr</strong> and <strong>writePtr</strong> navigate through the buffer incrementally, <strong>origBufferAddress</strong> is used to reset their position in the buffer.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">uint8_t</span> <span class="nf">readByte</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">readPtr</span> <span class="o">-</span> <span class="n">origBufferAddress</span> <span class="o">==</span> <span class="n">maxSize</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">readPtr</span> <span class="o">=</span> <span class="n">origBufferAddress</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">uint8_t</span> <span class="n">retVal</span> <span class="o">=</span> <span class="o">*</span><span class="n">readPtr</span><span class="p">;</span>
    <span class="n">readPtr</span> <span class="o">=</span> <span class="n">readPtr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">retVal</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">writeByte</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">byte</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">writePtr</span> <span class="o">-</span> <span class="n">origBufferAddress</span> <span class="o">==</span> <span class="n">maxSize</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">writePtr</span> <span class="o">=</span> <span class="n">origBufferAddress</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="o">*</span><span class="n">writePtr</span> <span class="o">=</span> <span class="n">byte</span><span class="p">;</span>
    <span class="n">writePtr</span> <span class="o">=</span> <span class="n">writePtr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>As the <strong>readPtr</strong> reads through the buffer, the <strong>maxSize</strong> ensures that it doesn’t read beyond the max bound of the buffer. This is done by taking the difference of the original buffer address and the current address of the read pointer. The difference is essentially the current index of the buffer from where the <strong>readPtr</strong> is retrieving data. If the difference is still within the bounds of the buffer, the <strong>readPtr</strong> retrieves the byte and carries on to read the neighbour byte.</p>

<p>The same logic applies for the <strong>writePtr</strong> as well. The <strong>writePtr</strong> writes the byte and moves on to the neighbour byte  .</p>

<p><strong>MISTAKE #1</strong></p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">Node</span><span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">val</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure>

<p>I actually started off with idea of using LinkedList to implement a circular buffer. Linkedlist has the obvious advantage of dynamic memory allocation. However, I had to think about the overhead of using singly/doubly and start pointers. Adding series of checks to prevent memory leaks and preserve the circular attribute of the buffer seemed a little excessive for a small example like this.</p>

<p><strong>MISTAKE #2</strong></p>

<p>I was foolish enough to forget this line of code.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span></code></pre></figure>


    </section>
</article>
<footer id="post-meta" class="clearfix">
    <a href="http://twitter.com/">
        <img class="avatar" src="/assets/images/profile.jpg">
        <div>
            <span class="dark">Himal Sherchan</span>
            <span>Discussions on programming, music, food, etc.</span>
        </div>
    </a>

    <section id="sharing">
        <a class="twitter" href="https://twitter.com/intent/tweet?text=hshercha.github.io/2016/Circular-Buffer/ - Circular Buffer by @"><span class="icon-twitter"> Tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>
    </section>
</footer>

<!-- Disqus comments -->


<!-- Archive post list -->





  </section>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script src="/assets/js/main.js"></script>
  <script src="/assets/js/highlight.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-XXXXXXXX-X', 'auto');
    ga('send', 'pageview');
  </script>
</body>
</html>



